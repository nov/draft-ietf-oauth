<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<rfc category='std' ipr='trust200902' docName='draft-hammer-oauth-v2-mac-token-00'>
  <?rfc strict='yes' ?>
  <?rfc toc='yes' ?>
  <?rfc tocdepth='3' ?>
  <?rfc symrefs='yes' ?>
  <?rfc sortrefs='yes' ?>
  <?rfc compact='yes' ?>
  <?rfc subcompact='no' ?>

  <front>
    <title abbrev='Token Authentication'>OAuth 2.0 MAC Token and Authentication</title>

    <author fullname='Eran Hammer-Lahav' surname='Hammer-Lahav' initials='E'>
      <organization>Yahoo!</organization>
      <address>
        <email>eran@hueniverse.com</email>
        <uri>http://hueniverse.com</uri>
      </address>
    </author>

    <date year='2010'/>

    <abstract>
      <t>
        This document specifies the OAuth 2.0 MAC token type and authentication scheme.
      </t>
    </abstract>

    <note>
      Please discuss this draft on the
      <eref target='https://www.ietf.org/mailman/listinfo/oauth'>oauth@ietf.org</eref> mailing
      list.
    </note>
  </front>

  <middle>

    <section title='Introduction'>
      <t>
        OAuth 2.0 (<xref target='I-D.ietf-oauth-v2' />) provides a token-based authentication
        framework in which third-party applications (clients) access protected resources using
        access tokens. Access tokens are obtained via the resource owners' authorization from an
        authorization server.
      </t>
      <t>
        OAuth 2.0 supports using different access token types based on the application security
        requirements. The decision which access token types to support and issue is left to the
        authorization server.
      </t>
      <t>
        This specification defines the MAC token type for use with the OAuth 2.0 framework. It
        defines additional token attributes and provides a method for making authenticated HTTP
        requests with partial cryptographic verification of the request, covering the HTTP
        method, request URI, and host, as well as some types of request body.
      </t>
      <t>
        This specification does not define methods for the client to specifically request a
        MAC-type token from the authorization server. It also does not include any discovery
        facilities for identifying which token types are supported by a resource server or how the
        client may go about obtaining an access token. This specification assumes that the
        authorization server has issued the client a MAC-type token and describes how the client
        authenticates using that access token.
      </t>
      <t>
        The MAC token type is based on the <spanx style='verb'>HMAC-SHA1</spanx> signature method
        defined in <xref target='RFC5849'>OAuth 1.0</xref>. However, the two schemes are not
        compatible.
      </t>
      <t>
        This specification is an extension of <xref target='I-D.ietf-oauth-v2' /> and uses its
        terminology.
      </t>

      <section title='Example'>
        <figure>
          <preamble>
            The client attempts to access a protected resource without authentication, making the
            following HTTP request to the resource server:
          </preamble>
          <artwork>
            <![CDATA[
  GET /resource/1?b=1&a=2 HTTP/1.1
  Host: example.com
]]>
          </artwork>
        </figure>
        <figure>
          <preamble>
            The resource server returns the following authentication challenge:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 401 Unauthorized
  WWW-Authenticate: OAuth2
  Date: Thu, 02 Dec 2010 21:39:45 GMT
]]>
          </artwork>
        </figure>
        <t>
          The client has previously obtained a set of token credentials for accessing resources on
          the <spanx style='verb'>http://example.com/</spanx> resource server. The credentials issued to the
          client by the authorization server included the following attributes:

          <list style='hanging' hangIndent='6'>
            <t hangText='Access token:'>h480djs93hd8</t>
            <t hangText='Token type:'>mac</t>
            <t hangText='MAC algorithm:'>hmac-sha-1</t>
            <t hangText='Token secret:'>489dks293j39</t>
          </list>
        </t>
        <t>
          The client attempts the HTTP request again, this time using the token credentials
          issued by the authorization server earlier to authenticate. To construct the request,
          the client calculates a timestamp and nonce. The nonce is typically a random string,
          unique to the timestamp used:

          <list style='hanging' hangIndent='6'>
            <t hangText='Timestamp:'>137131200</t>
            <t hangText='Nonce:'>dj83hs9s</t>
          </list>
        </t>
        <t>
          The client normalizes the request and constructs the signature base string (the newline
          seperator character is represented by <spanx style='verb'>\n</spanx> for display purposes
          only):
        </t>
        <figure>
          <artwork>
            <![CDATA[
  h480djs93hd8\n
  137131200\n
  dj83hs9s\n
  GET\n
  example.com\n
  80\n
  /resource/1\n
  a=2\n
  b=1
]]>
          </artwork>
        </figure>
        <t>
          The signature base string is signed using the specified MAC token algorithm
          <spanx style='verb'>hmac-sha-1</spanx> with the signature base string as text and the
          token secret as key. The resulting digest is base64-encoded to produce the request
          signature:
        </t>
        <figure>
          <artwork>
            <![CDATA[
  digest = HMAC-SHA1 (key, text)
  signature = BASE64 (digest)
]]>
          </artwork>
        </figure>
        <t>
          The client includes the access token, timestamp, nonce, and signature with the the
          request using the <spanx style='verb'>Authorization</spanx> request header field:
        </t>
        <figure>
          <artwork>
            <![CDATA[
  GET /resource/1 HTTP/1.1
  Host: example.com
  Authorization: OAuth2-MAC
                 token='h480djs93hd8',
                 timestamp='137131200',
                 nonce='dj83hs9s',
                 signature='IdSrHQHTwCPWGrqzGGIR791ZJXE='
]]>
          </artwork>
        </figure>
        <t>
          After validating the request by calculating the signature again and verifying the
          validity and scope of the access token, the resource server responds with the requested
          protected resource representation.
        </t>
      </section>

      <section title='Notational Conventions'>
        <t>
          The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT', 'SHOULD', 'SHOULD NOT',
          'RECOMMENDED', 'MAY', and 'OPTIONAL' in this document are to be interpreted as described in
          <xref target='RFC2119' />.
        </t>
        <t>
          This document uses the Augmented Backus-Naur Form (ABNF) notation of
          <xref target='I-D.ietf-httpbis-p1-messaging' />. Additionally, the following rules are
          included from <xref target='RFC2617' />: realm, auth-param.
        </t>
      </section>

    </section>

    <section title='Issuing MAC-Type Access Tokens' anchor='issue'>
      <t>
        Authorization servers issuing MAC-type access tokens MUST include the following parameters
        whenever a response includes the <spanx style='verb'>access_token</spanx> parameter:
        
        <list style='hanging' hangIndent='6'>
          <t hangText='secret'>
            <vspace />
            REQUIRED. The token shared secret used as the MAC algorithm key.
          </t>
          <t hangText='algorithm'>
            <vspace />
            REQUIRED. The MAC algorithm used to calculate the request signature. Value MUST be one
            of <spanx style='verb'>hmac-sha-1</spanx>, <spanx style='verb'>hmac-sha-256</spanx>, or
            a registered extension algorithm name.
          </t>
        </list>
      </t>
    </section>

    <section title='Making Requests' anchor='requests'>
      <t>
        To make authenticated requests, the client must be in the possession of a valid MAC-type
        access token, issued by an authorization server accepted by the resource server. The client makes authenticated requests by obtaining a MAC-type access token, calculating
        the values of a set of attributes, and adding them to the HTTP request using the
        <xref target='authz_header'>Authorization header field</xref>. Authenticated request can be
        sent either directly (without first receiving a challenge), or in response to an
        authentication challenge.
      </t>
      <t>
        Once a valid MAC-type access token is obtained, the client:

        <list style='numbers'>
          <t>
            Assign values based on its selection to the following attributes:

            <list style='symbols'>
              <t>
                <spanx style='verb'>token</spanx>
              </t>
              <t>
                <spanx style='verb'>coverage</spanx>
              </t>
            </list>
          </t>
          <t>
            If the client uses a coverage method other than <spanx style='verb'>none</spanx> it
            MUST assign values to the following attributes:

            <list style='symbols'>
              <t>
                <spanx style='verb'>nonce</spanx>
              </t>
              <t>
                <spanx style='verb'>timestamp</spanx>
              </t>
            </list>
          </t>
          <t>
            Assigns value to any additional method-specific, or coverage-specific attributes as
            defined by protocol extensions.
          </t>
          <t>
            If the client uses a coverage method other than <spanx style='verb'>none</spanx> it
            constructs the normalized request string based on the selected coverage as described in
            <xref target='coverage' />.
          </t>
          <t>
            Calculates the value of the <spanx style='verb'>auth</spanx> attribute as defined by
            the selected authentication method.
          </t>
          <t>
            Adds the assigned attributes to the request via the
            <xref target='authz_header'>Authorization header field</xref>.
          </t>
          <t>
            Sends the authenticated HTTP request to the server.
          </t>
        </list>
      </t>
    </section>

    <section title='Verifying Requests' anchor='verify_request'>
      <t>
        A servers receiving an authenticated request validates it by performing the following
        REQUIRED steps:

        <list style='numbers'>
          <t>
            Verify that the token used by the client as well as the coverage method matches the
            server's requirements.
          </t>
          <t>
            If the client used a coverage method other than <spanx style='verb'>none</spanx>,
            construct the normalized request string based on the selected coverage as described in
            <xref target='coverage' />.
          </t>
          <t>
            If the client used an authentication method other than <spanx style='verb'>none</spanx>,
            recalculate the value of the <spanx style='verb'>auth</spanx> attribute as described in
            <xref target='methods' /> and compare it to the value received from the client via
            the <spanx style='verb'>auth</spanx> attribute.
          </t>
          <t>
            If the client used a coverage method other than <spanx style='verb'>none</spanx>,
            ensure that the combination of nonce, timestamp, and token received from the client has
            not been used before in a previous request (the server MAY reject requests with stale
            timestamps; the determination of staleness is left up to the server to define).
          </t>
          <t>
            Verify the scope and status of the client credentials as represented by the token.
          </t>
        </list>
      </t>
      <t>
        If the request fails verification, the server SHOULD respond with an HTTP 401 (unauthorized)
        status code, and SHOULD include a token scheme authentication challenge using the
        <xref target='error_header'>WWW-Authenticate header field</xref>. The server MAY include
        further details about why the request was rejected using the
        <xref target='error_header'>Authorization-Error header field</xref>.
      </t>
    </section>

    <section title='The Authorization Request Header' anchor='authz_header'>
      <t>
        A client making a request for a protected resource either directly, or in retrying a
        request after receiving a 401 status code (Unauthorized) with a token challenge, MUST
        include at least one <spanx style='verb'>Authorization</spanx> header field including
        token scheme credentials.
      </t>
      <t>
        The <spanx style='verb'>Authorization</spanx> header field uses the framework defined by
        <xref target='RFC2617' /> as follows:
      </t>
      <figure>
        <artwork>
          <![CDATA[
 credentials    = 'Token' RWS token-response
   
 token-response = token-id
                  CS coverage
                  [ CS nonce ]
                  [ CS timestamp ]
                  [ CS auth ]

 token-id         = 'token' '=' <'> token <'>
 coverage         = 'coverage' '=' <'> coverage-name <'>
 nonce            = 'nonce' '=' <'> token <'>
 auth             = 'auth' '=' <'> token <'>
]]>
        </artwork>
      </figure>

      <section title='The "token" Attribute'>
        <t>
          The value used to identify the set of token credentials used by the client to
          authenticate. The token identifier can be an opaque string or use a well-defined internal
          structure.
        </t>
      </section>

      <section title='The "coverage" Attribute'>
        <t>
          The name of the authentication coverage method used by the client to make the request.
          If the attribute is omitted, its value defaults to <spanx style='verb'>base</spanx>.
        </t>
      </section>

      <section title='The "nonce" Attribute'>
        <t>
          A random string, uniquely generated by the client to allow the server to verify that a
          request has never been made before and helps prevent replay attacks when requests are
          made over a non-secure channel. The nonce value MUST be unique across all requests with
          the same timestamp and token combinations.
        </t>
      </section>

      <section title='The "timestamp" Attribute'>
        <t>
          The timestamp value is the current time expressed in the number of seconds since
          January 1, 1970 00:00:00 GMT, and MUST be a positive integer.
        </t>
      </section>

      <section title='The "signature" Attribute'>
        <t>
          The output of the authentication method function after applying it to the selected
          coverage as described in <xref target='methods' />.
        </t>
      </section>

    </section>

    <section title='Authentication Methods' anchor='methods'>
      <t>
        In order for the server to verify the authenticity of the request and prevent unauthorized
        access, the client must prove it is the rightful owner of the credentials. This is
        accomplished using the authentication method associated with the token.
      </t>
      <t>
        This specification provides three methods for the client to prove its rightful ownership of
        the credentials: <spanx style='verb'>hmac-sha-1</spanx>, <spanx style='verb'>hmac-sha-256</spanx>,
        and <spanx style='verb'>rsassa-pkcs1-v1.5-sha-256</spanx>. In addition, the
        <spanx style='verb'>none</spanx> method is defined to allow the use of bearer token which
        does not utilizes any cryptographic means.
      </t>
      <figure>
        <artwork>
          <![CDATA[
 method-name     = 'none' /
                   'hmac-sha-1' /
                   'hmac-sha-256' /
                   'rsassa-pkcs1-v1.5-sha-256' /
                   token
]]>
        </artwork>
      </figure>
      <t>
        The authentication process does not change the request or its parameters, with the exception
        of the <spanx style='verb'>auth</spanx> attribute.
      </t>

      <section title='The "hmac-sha-1" Method'>
        <t>
          The <spanx style='verb'>hmac-sha-1</spanx> authentication method uses the HMAC-SHA1
          algorithm as defined in <xref target='RFC2104' />:

          <figure>
            <artwork>
              <![CDATA[
  digest = HMAC-SHA1 (key, text)
]]>
            </artwork>
          </figure>
        </t>
        <t>
          The HMAC-SHA1 function variables are used in following way:

          <list style='hanging' hangIndent='6'>
            <t hangText='text'>
              <vspace />
              is set to the value of the normalize request string as described in
              <xref target='coverage' />.
            </t>
            <t hangText='key'>
              <vspace />
              is set to the shared-secret associated with the token.
            </t>
            <t hangText='digest'>
              <vspace />
              is used to set the value of the <spanx style='verb'>auth</spanx>
              attribute, after the result octet string is base64-encoded per
              <xref target='RFC2045' /> section 6.8.
            </t>
          </list>
        </t>
      </section>

      <section title='The "hmac-sha-256" Method'>
        <t>
          The <spanx style='verb'>hmac-sha-256</spanx> authentication method uses the HMAC
          algorithm as defined in <xref target='RFC2104' /> together with the SHA-256 hash
          function defined in <xref target='NIST FIPS-180-3' />:

          <figure>
            <artwork>
              <![CDATA[
  digest = HMAC-SHA256 (key, text)
]]>
            </artwork>
          </figure>
        </t>
        <t>
          The HMAC-SHA256 function variables are used in following way:

          <list style='hanging' hangIndent='6'>
            <t hangText='text'>
              <vspace />
              is set to the value of the normalize request string as described in
              <xref target='coverage' />.
            </t>
            <t hangText='key'>
              <vspace />
              is set to the shared-secret associated with the token.
            </t>
            <t hangText='digest'>
              <vspace />
              is used to set the value of the <spanx style='verb'>auth</spanx>
              attribute, after the result octet string is base64-encoded per
              <xref target='RFC2045' /> section 6.8.
            </t>
          </list>
        </t>
      </section>

    </section>

    <section title='Coverage Methods' anchor='coverage'>
      <t>
        The normalized request string is a consistent, reproducible concatenation of several
        of the HTTP request elements into a single string. The string is used as an input to
        the authentication methods with the exception of <spanx style='verb'>none</spanx>.
      </t>

      <section title='The "base" Method'>
        <t>
          When using the <spanx style='verb'>base</spanx> method, the normalized request string
          includes the following components of the HTTP request:

          <list style='symbols'>
            <t>
              The HTTP request method (e.g. <spanx style='verb'>GET</spanx>,
              <spanx style='verb'>POST</spanx>, etc.).
            </t>
            <t>
              The authority as declared by the HTTP <spanx style='verb'>Host</spanx> request
              header.
            </t>
            <t>
              The request resource URI.
            </t>
            <t>
              The <xref target='authz_header'>Authorization header field</xref> attributes, with the
              exception of the <spanx style='verb'>auth</spanx> attribute.
            </t>
          </list>
        </t>
        <t>
          The <spanx style='verb'>base</spanx> normalized request string does not cover the entire
          HTTP request. Most notably, it does not include the entity-body or most HTTP
          entity-headers. It is important to note that the server cannot verify the authenticity
          of the excluded request elements without using additional protections such as SSL/TLS or
          other methods.
        </t>

        <section title='String Construction' anchor='base_string'>
          <t>
            The normalized request string is constructed by concatenating together, in order, the
            following HTTP request elements:

            <list style='numbers'>
              <t>
                The HTTP request method in uppercase. For example: <spanx style='verb'>HEAD</spanx>,
                <spanx style='verb'>GET</spanx>, <spanx style='verb'>POST</spanx>, etc.
              </t>
              <t>
                A <spanx style='verb'>,</spanx> character (ASCII code 44).
              </t>
              <t>
                The hostname, colon-separated (ASCII code 58) from the TCP port used to make the
                request as included in the HTTP request <spanx style='verb'>Host</spanx> header
                field. The port MUST be included even if it is not included in the
                <spanx style='verb'>Host</spanx> header field (i.e. the default port for the
                scheme).
              </t>
              <t>
                A <spanx style='verb'>,</spanx> character (ASCII code 44).
              </t>
              <t>
                Any authentication attribute, with the exception of the <spanx style='verb'>auth</spanx>,
                which is assigned a value (including default values), are added to the normalized
                request string as follows:

                <list style='numbers'>
                  <t>
                    The name of each parameter is concatenated to its corresponding value using an
                    <spanx style='verb'>=</spanx> character (ASCII code 61) as separator, even if the
                    value is empty.
                  </t>
                  <t>
                    The name/value pairs are sorted using ascending byte value ordering.
                  </t>
                  <t>
                    The sorted name/value pairs are concatenated together into a single string by
                    using a <spanx style='verb'>,</spanx> character (ASCII code 44) as separator.
                  </t>
                </list>
              </t>
              <t>
                A <spanx style='verb'>,</spanx> character (ASCII code 44).
              </t>
              <t>
                The request resource URI.
              </t>
            </list>
          </t>
        </section>

      </section>

      <section title='The "base+body-hmac-sha-256" Method'>
        <t>
          The <spanx style='verb'>base+body-hmac-sha-256</spanx> method added the request entity-body
          to the elements included in the normalized request string. It does not include the
          entity-body directly in the normalized string. Instead, it calculates the hash value of
          the entity-body using the SHA-256 hash function defined in <xref target='NIST FIPS-180-3' />.
        </t>
        <t>
          The normalized request string is constructed following the same process defined in
          <xref target='base_string' />, with the following addition:

          <list style='symbols'>
            <t>
              Before constructing the string, the entity-body hash is calculated by applying the
              SHA-256 hash function on the raw entity-body content.
            </t>
            <t>
              The hash value is added to the list of authentication attributes by assigning its
              value to the <spanx style='verb'>body-hash</spanx> attribute name. This is done
              prior to the attributes being sorted and added to the string.
            </t>
            <t>
              The <spanx style='verb'>body-hash</spanx> attribute is only included in the
              normalized request string and is not added to the
              <xref target='authz_header'>Authorization header field</xref>.
            </t>
          </list>
        </t>
      </section>

    </section>

    <section title='Scheme Extensions'>
      <t>
      </t>
    </section>

    <section title='Security Considerations' anchor='Security'>
      <t>
        As stated in <xref target='RFC2617' />, the greatest sources of risks are usually found not
        in the core protocol itself but in policies and procedures surrounding its use. Implementers
        are strongly encouraged to assess how this protocol addresses their security requirements.
      </t>

      <section title='Credentials Transmission'>
        <t>
          This specification does not describe any mechanism for obtaining or transmitting raw
          tokens credentials. Methods used to obtain tokens should ensure that these transmissions
          are protected using transport-layer mechanisms such as TLS or SSL.
        </t>
      </section>

      <section title='Confidentiality of Requests'>
        <t>
          While this protocol provides a mechanism for verifying the integrity of requests, it
          provides no guarantee of request confidentiality. Unless further precautions are taken,
          eavesdroppers will have full access to request content. Servers should carefully consider
          the kinds of data likely to be sent as part of such requests, and should employ
          transport-layer security mechanisms to protect sensitive resources.
        </t>
      </section>

      <section title='Spoofing by Counterfeit Servers'>
        <t>
          This protocol makes no attempt to verify the authenticity of the server. A hostile party
          could take advantage of this by intercepting the client's requests and returning
          misleading or otherwise incorrect responses. Service providers should consider such
          attacks when developing services using this protocol, and should require transport-layer
          security for any requests where the authenticity of the server or of request responses is
          an issue.
        </t>
      </section>

      <section title='Plaintext Storage of Credentials'>
        <t>
          When used with a symmetric shared-secret authentication method, the token shared-secret
          function the same way passwords do in traditional authentication systems. In order to
          compute the signatures used in methods, the server must have access to these secrets in
          plaintext form. This is in contrast, for example, to modern operating systems, which
          store only a one-way hash of user credentials.
        </t>
        <t>
          If an attacker were to gain access to these secrets - or worse, to the server's database
          of all such secrets - he or she would be able to perform any action on behalf of any
          resource owner. Accordingly, it is critical that servers protect these secrets from
          unauthorized access.
        </t>
      </section>

      <section title='Scoping of Access Requests'>
        <t>
          By itself, this protocol does not provide any method for scoping the access rights
          granted to a client. However, most applications do require greater granularity of access
          rights. For example, servers may wish to make it possible to grant access to some
          protected resources but not others, or to grant only limited access (such as read-only
          access) to those protected resources.
        </t>
        <t>
          When implementing this protocol, servers should consider the types of access resource
          owners may wish to grant clients, and should provide mechanisms to do so. Servers should
          also take care to ensure that resource owners understand the access they are granting, as
          well as any risks that may be involved.
        </t>
      </section>

      <section title='Entropy of Secrets'>
        <t>
          Unless a transport-layer security protocol is used, eavesdroppers will have full access
          to authenticated requests and signatures, and will thus be able to mount offline brute-force
          attacks to recover the credentials used. Servers should be careful to assign
          shared-secrets which are long enough, and random enough, to resist such attacks for at
          least the length of time that the shared-secrets are valid.
        </t>
        <t>
          For example, if shared-secrets are valid for two weeks, servers should ensure that it is
          not possible to mount a brute force attack that recovers the shared-secret in less than
          two weeks. Of course, servers are urged to err on the side of caution, and use the longest
          secrets reasonable.
        </t>
        <t>
          It is equally important that the pseudo-random number generator (PRNG) used to generate
          these secrets be of sufficiently high quality. Many PRNG implementations generate number
          sequences that may appear to be random, but which nevertheless exhibit patterns or other
          weaknesses which make cryptanalysis or brute force attacks easier. Implementers should be
          careful to use cryptographically secure PRNGs to avoid these problems.
        </t>
      </section>

      <section title='Denial of Service / Resource Exhaustion Attacks'>
        <t>
          This specification includes a number of features which may make resource exhaustion
          attacks against servers possible. For example, this protocol requires servers to track
          used nonces. If an attacker is able to use many nonces quickly, the resources required to
          track them may exhaust available capacity. And again, this protocol can require servers
          to perform potentially expensive computations in order to verify the signature on
          incoming requests. An attacker may exploit this to perform a denial of service attack by
          sending a large number of invalid requests to the server.
        </t>
        <t>
          Resource Exhaustion attacks are by no means specific to this specification. However,
          implementers should be careful to consider the additional avenues of attack that this
          protocol exposes, and design their implementations accordingly. For example, entropy
          starvation typically results in either a complete denial of service while the system
          waits for new entropy or else in weak (easily guessable) secrets. When implementing this
          protocol, servers should consider which of these presents a more serious risk for their
          application and design accordingly.
        </t>
      </section>

      <section title='Coverage Limitations'>
        <t>
          The normalized request string has been designed to support the authentication methods
          defined in this specification. Those designing additional methods, should evaluated the
          compatibility of the normalized request string with their security requirements.
          Since the normalized request string does not cover the entire HTTP request, servers
          should employ additional mechanisms to protect such elements.
        </t>
      </section>

    </section>

    <section title='IANA Considerations' anchor='IANA'>

      <section title='The "secret" OAuth Parameter'>
        <t>
          The following is the parameter registration request for the
          <spanx style='verb'>scope</spanx> parameter as defined in this specification:

          <list style='hanging'>
            <t hangText='Parameter name:'>
              scope
            </t>
            <t hangText='Parameter usage location:'>
              The end-user authorization endpoint request, the end-user authorization endpoint
              response, the token endpoint request, the token endpoint response, and the
              <spanx style='verb'>WWW-Authenticate</spanx> header field.
            </t>
            <t hangText='Change controller:'>
              IETF
            </t>
            <t hangText='Specification document(s):'>
              [[ this document ]]
            </t>
            <t hangText='Related information:'>
              None
            </t>
          </list>
        </t>
      </section>

    </section>

    <section title='Acknowledgments'>
      <t>
        The author would like to thank Richard Barnes, Breno de Medeiros, Brian Eaton, Ben Laurie,
        Mark Nottingham, John Panzer, and Peter Saint-Andre for their suggestions, feedback, and
        continued support.
      </t>
    </section>

    <appendix title='Document History' anchor='history'>
      <t>
        [[ To be removed by the RFC editor before publication as an RFC. ]]
      </t>
      <t>
        -01

        <list style='symbols'>
          <t>
            Simplified challenge, moving the supported authentication methods to the token
            definition, as well as using the 'realm' parameter as defined by RFC 2617 instead of
            the 'class' parameter (which has been dropped).
          </t>
        </list>
      </t>
      <t>
        -00

        <list style='symbols'>
          <t>
            Initial (incomplete) draft.
          </t>
        </list>
      </t>
    </appendix>

  </middle>

  <back>

    <references title='Normative References'>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p1-messaging-08.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-v2-11.xml' ?>

      <reference anchor='NIST FIPS-180-3'>
        <front>
          <title>Secure Hash Standard (SHS). FIPS PUB 180-3, October 2008</title>
          <author>
            <organization>National Institute of Standards and Technology</organization>
          </author>
        </front>
        <format type='pdf' target='http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf' />
      </reference>

    </references>

    <references title='Informative References'>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5849.xml' ?>

    </references>
  </back>

</rfc>