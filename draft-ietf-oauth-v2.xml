<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<rfc category='std' ipr='trust200902' obsoletes='5849' docName='draft-ietf-oauth-v2-11'>
  <?rfc strict='yes' ?>
  <?rfc toc='yes' ?>
  <?rfc tocdepth='3' ?>
  <?rfc symrefs='yes' ?>
  <?rfc sortrefs='yes' ?>
  <?rfc compact='yes' ?>
  <?rfc subcompact='no' ?>

  <front>
    <title abbrev='OAuth 2.0'>The OAuth 2.0 Protocol Framework</title>

    <author fullname='Eran Hammer-Lahav' surname='Hammer-Lahav' initials='E' role='editor'>
      <organization>Yahoo!</organization>
      <address>
        <email>eran@hueniverse.com</email>
        <uri>http://hueniverse.com</uri>
      </address>
    </author>
    <author fullname='David Recordon' surname='Recordon' initials='D'>
      <organization>Facebook</organization>
      <address>
        <email>davidrecordon@facebook.com</email>
        <uri>http://www.davidrecordon.com/</uri>
      </address>
    </author>
    <author fullname='Dick Hardt' surname='Hardt' initials='D'>
      <organization>Microsoft</organization>
      <address>
        <email>dick.hardt@gmail.com</email>
        <uri>http://dickhardt.org/</uri>
      </address>
    </author>

    <date year='2010' />

    <abstract>
      <t>
        This specification describes the OAuth 2.0 protocol framework.
      </t>
    </abstract>
  </front>

  <middle>

    <section title='Introduction'>
      <t>
        With the increasing use of distributed web services and cloud computing, third-party
        applications require access to server-hosted resources. These resources are usually
        protected and require authentication using the resource owner's credentials (typically a
        username and password).
      </t>
      <t>
        In the traditional client-server authentication model, the client accesses a protected
        resource on the server by authenticating with the server using the resource owner's
        credentials. In order to provide third-party applications access to protected resources,
        the resource owner shares its credentials with the third-party. This creates several
        problems and limitations:

        <list style='symbols'>
          <t>
            Third-party applications are required to store the resource-owner's credentials
            for future use, typically a password in clear-text.
          </t>
          <t>
            Servers are required to support password authentication, despite the security
            weaknesses created by passwords.
          </t>
          <t>
            Third-party applications gain overly broad access to the resource-owner's protected
            resources, leaving resource owners without any ability to restrict access to a limited
            subset of resources, to limit access duration, or to limit access to the methods
            supported by these resources.
          </t>
          <t>
            Resource owners cannot revoke access to an individual third-party without revoking
            access to all third-parties, and must do so by changing their password.
          </t>
        </list>
      </t>
      <t>
        OAuth addresses these issues by separating the role of the client from that of the
        resource owner. In OAuth, the client (which is usually not the resource owner, but is
        acting on the resource owner's behalf) requests access to resources controlled by the
        resource owner and hosted by the resource server, and is issued a different set of
        credentials than those of the resource owner.
      </t>
      <t>
        Instead of using the resource owner's credentials to access protected resources, clients
        obtain an access token (a string which denotes a specific scope, duration, and other
        attributes). The format and structure of access tokens is beyond the scope of this
        specification.
      </t>
      <t>
        Tokens are issued to third-party clients by an authorization server with the approval of
        the resource owner. The client uses the access token to access the protected resources
        hosted by the resource server. The interaction between the authorization server and
        resource server is beyond the scope of this specification.
      </t>
      <t>
        For example, a web user (resource owner) can grant a printing service (client) access to
        her protected photos stored at a photo sharing service (resource server), without sharing
        her username and password with the printing service. Instead, she authenticates directly
        with an authentication service trusted by the photo sharing service (authorization server)
        which issues the printing service delegation-specific credentials (token).
      </t>
      <t>
        This specification describes the OAuth protocol framework and defines methods for obtaining
        access tokens using resource owner credentials over <xref target='RFC2616'>HTTP</xref>
        (or HTTP over TLS as defined by <xref target='RFC2818' />). The access tokens format and
        attributes (e.g. cryptographic properties), as well as the methods for using access tokens
        to access protected resource are defined by companion specifications.
      </t>

      <section title='Notational Conventions'>
        <t>
          The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT', 'SHOULD', 'SHOULD
          NOT', 'RECOMMENDED', 'MAY', and 'OPTIONAL' in this document are to be interpreted as
          described in <xref target='RFC2119' />.
        </t>
        <t>
          This document uses the Augmented Backus-Naur Form (ABNF) notation of
          <xref target='I-D.ietf-httpbis-p1-messaging' />. Additionally, the following rules are
          included from <xref target='RFC2617' />: auth-param; from
          <xref target='RFC3986' />: URI-Reference; and from
          <xref target='I-D.ietf-httpbis-p1-messaging' />: OWS, RWS, and quoted-string.
        </t>
        <t>
          Unless otherwise noted, all the protocol parameter names and values are case sensitive.
        </t>
      </section>

      <section title='Terminology'>
        <t>
          <list style='hanging' hangIndent='6'>
            <t hangText='protected resource'>
              <vspace />
              An access-restricted resource which can be obtained using an OAuth-authenticated
              request.
            </t>
            <t hangText='resource server'>
              <vspace />
              A server capable of accepting and responding to protected resource requests.
            </t>
            <t hangText='client'>
              <vspace />
              An application obtaining authorization and making protected resource requests.
            </t>
            <t hangText='resource owner'>
              <vspace />
              An entity capable of granting access to a protected resource.
            </t>
            <t hangText='end-user'>
              <vspace />
              A human resource owner.
            </t>
            <t hangText='token'>
              <vspace />
              A string representing an access authorization issued to the client. The string is
              usually opaque to the client. Tokens represent specific scopes and durations of
              access, granted by the resource owner, and enforced by the resource server and
              authorization servers. The token may denote an identifier used to retrieve the
              authorization information, or self-contain the authorization information in a
              verifiable manner (i.e. a token string consisting of some data and a signature).
              Tokens may be pure capabilities. Specific additional authentication credentials may
              be required in order for a client to use a token.
            </t>
            <t hangText='access token'>
              <vspace />
              A token used by the client to make authenticated requests on behalf of the resource
              owner.
            </t>
            <t hangText='refresh token'>
              <vspace />
              A token used by the client to obtain a new access token without having to involve
              the resource owner.
            </t>
            <t hangText='authorization code'>
              A short-lived token representing the authorization provided by the end-user. The
              authorization code is used to obtain an access token and a refresh token.
            </t>
            <t hangText='access grant'>
              A general term used to describe the intermediate credentials (such as an end-user
              password or authorization code) representing the resource owner authorization. Access
              grants are used by the client to obtain an access token. By exchanging access
              grants of different types for an access token, the resource server is only required
              to support a single authentication scheme.
            </t>
            <t hangText='authorization server'>
              <vspace />
              A server capable of issuing tokens after successfully authenticating the resource
              owner and obtaining authorization. The authorization server may be the same server as
              the resource server, or a separate entity. A single authorization server may issue
              tokens for multiple resource servers.
            </t>
            <t hangText='end-user authorization endpoint'>
              <vspace />
              The authorization server's HTTP endpoint capable of authenticating the end-user and
              obtaining authorization. The end-user authorization endpoint is described in
              <xref target='user-authorization' />.
            </t>
            <t hangText='token endpoint'>
              <vspace />
              The authorization server's HTTP endpoint capable of issuing tokens and refreshing
              expired tokens. The token endpoint is described in <xref target='obtaining-token' />.
            </t>
            <t hangText='client identifier'>
              <vspace />
              A unique identifier issued to the client to identify itself to the authorization
              server. Client identifiers may have a matching secret. The client identifier is
              described in <xref target='client-authentication' />.
            </t>
          </list>
        </t>
      </section>

      <section title='Overview'>
        <t>
          OAuth provides a method for clients to access a protected resource on behalf of a
          resource owner. Before a client can access a protected resource, it must first obtain
          authorization (access grant) from the resource owner, then exchange the access grant for
          an access token (representing the grant's scope, duration, and other attributes). The
          client accesses the protected resource by presenting the access token to the resource
          server.
        </t>
        <t>
          The access token provides an abstraction layer, replacing different authorization
          constructs (e.g. username and password, assertion) for a single token understood by the
          resource server. This abstraction enables issuing access tokens valid for a short time
          period, as well as removing the resource server's need to understand a wide range of
          authentication schemes.
        </t>
        <figure title='Abstract Protocol Flow' anchor='Figure 1'>
          <artwork>
            <![CDATA[
  +--------+                               +---------------+
  |        |--(A)- Authorization Request ->|   Resource    |
  |        |                               |     Owner     |
  |        |<-(B)----- Access Grant -------|               |
  |        |                               +---------------+
  |        |
  |        |           Access Grant &      +---------------+
  |        |--(C)--- Client Credentials -->| Authorization |
  | Client |                               |     Server    |
  |        |<-(D)----- Access Token -------|               |
  |        |                               +---------------+
  |        |
  |        |                               +---------------+
  |        |--(E)----- Access Token ------>|    Resource   |
  |        |                               |     Server    |
  |        |<-(F)--- Protected Resource ---|               |
  +--------+                               +---------------+
]]>
          </artwork>
        </figure>
        <t>
          The abstract flow illustrated in <xref target='Figure 1' /> describes the overall
          protocol architecture and includes the following steps:

          <list style='format (%C)'>
            <t>
              The client requests authorization from the resource owner. The authorization request
              can be made directly to the resource owner, or preferebly indirectly via an
              intermediary such as an authorization server.
            </t>
            <t>
              The client receives an access grant which represents the authorization provided by
              the resource owner.
            </t>
            <t>
              The client requests an access token by authenticating with the authorization server
              using its client credentials, and presenting the access grant.
            </t>
            <t>
              The authorization server validates the client credentials and the access grant, and
              if valid issues an access token.
            </t>
            <t>
              The client makes a protected resource request to the resource server by presenting
              the access token.
            </t>
            <t>
              The resource server validates the access token, and if valid, serves the request.
            </t>
          </list>
        </t>
      </section>

      <section title='Access Grants'>
        <t>
          The access grant represents the authorization provided by the resource owner. The access
          grant type depends on the method used by the client and supported by the authorization
          server to obtain it.
        </t>

        <section title='Authorization Code'>
          <t>
            The authorization code is an access grant obtained by directing the end-user to an
            authorization server. The authorization server authenticates the end-user, obtains
            authorization, and issues the an authorization code to the client. Because the end-user
            only authenticates with the authorization server, the end-user's password is never
            shared with the client.
          </t>
          <t>
            The authorization code access grant is suitable when the client is interacting with an
            end-user via a user-agent.
          </t>
          <figure title='Obtaining an Authorization Code' anchor='Figure 2'>
            <artwork>
              <![CDATA[
  +----------+
  |          |
  | End-User |
  |          |
  +----------+
       ^
       |
      (B)      
  +----|-----+        Client Identifier     +---------------+
  |         -+--(A)--- & Redirect URI ----->|               |
  |  User-   |                              | Authorization |
  |  Agent  -|--(B)-- User authenticates -->|     Server    |
  |          |                              |               |
  |         -+--(C)-- Authorization Code --<|               |
  +-|----|---+                              +---------------+
   (A)  (C)
    |    |
    ^    v
  +---------+
  |         |
  |  Client |
  |         |
  +---------+
]]>
            </artwork>
          </figure>
          <t>
            The authorization code flow illustrated in <xref target='Figure 2' /> includes the
            following steps:

            <list style='format (%C)'>
              <t>
                The client initiates the flow by directing the end-user's user-agent to the
                authorization server's end-user authorization endpoint. The client includes its
                client identifier, requested scope, local state, and a redirection URI (to which
                the authorization server will send the user-agent back once access is granted or
                denied).
              </t>
              <t>
                The authorization server authenticates the end-user (via the user-agent) and
                establishes whether the end-user grants or denies the client's access request.
              </t>
              <t>
                If access is granted, the authorization server directs the user-agent back to the
                client using the redirection URI provided. The authorization server includes an
                authorization code for the client to use to obtain an access token.
              </t>
            </list>
          </t>
          <t>
            Once the client obtains an authorization code, it requests an access token by
            authenticating with the authorization server (using its client credentials) and
            presenting the authorization code (access grant).
          </t>
          <t>
            In cases where the client is incapable of maintaining its client credentials secret
            (such as native applications or an application implemented as a user-agent script), the
            authorization server issues an access token directly to the client in step (C), instead
            of issuing an authorization code.
          </t>
          <t>
            Obtaining an authorization code is described in <xref target='user-authorization' />.
          </t>
        </section>

        <section title='Resource Owner Password Credentials'>
          <t>
            The resource owner password credentials (e.g. a username and password) can be used
            directly as an access grant to obtain an access token. The credentials should only be
            used when there is a high degree of trust between the resource owner and the client
            (e.g. its computer operating system or a highly privileged application), and when
            other access grant types are not available (such as an authorization code).
          </t>
          <t>
            Even though this grant type requires direct client access to the resource owner's
            credentials, the resource owner's credentials are used for a single request and are
            exchanged for an access token. Unlike the HTTP Basic authentication scheme defined in
            <xref target='RFC2617' />, this grant type eliminates the need for the client to store
            the resource-owner's credentials for future use.
          </t>
          <t>
            In <xref target='Figure 3' />, the client requests authorization from the resource
            owner directly. When interacting with an end-user, the client typically promopts the
            end-user for the username and password.
          </t>
          <figure title='Obtaining Resource Owner Password Credentials' anchor='Figure 3'>
            <artwork>
              <![CDATA[
  +--------+                               +----------+
  |        |--(A)- Authorization Request ->| Resource |
  | Client |                               |   Owner  |
  |        |<-(B)-- Username & Password ---|          |
  +--------+                               +----------+
]]>
            </artwork>
          </figure>
        </section>

        <section title='Client Credentials'>
          <t>
            The client credentials can be used as an access grant when the authorization scope is
            limited to the protected resources under the control of the client, or other protected
            resources previously arranged with the authorization server. Client credentials are
            used as an access grant typically when the client is acting on its own behalf (the
            client is also the resource owner).
          </t>
        </section>

        <section title='Refresh Token'>
          <t>
            Access tokens usually have a shorter lifetime than authorized by the resource owner.
            When issuing an access token, the authorization server can include a refresh token
            which is used by the client to obtain a new access token when the current access token
            expires. When requesting a new access token, the refresh token acts as an access grant.
            Using a refresh token removes the need to interact with the resource owner again, or to
            store the original access grant used to obtain the access token and refresh token.
          </t>
          <figure title='Refreshing an Access Token' anchor='Figure 4'>
            <artwork>
              <![CDATA[
  +--------+          Access Grant &      +---------------+
  |        |--(A)-- Client Credentials -->| Authorization |
  |        |                              |     Server    |
  |        |<-(B)---- Access Token -------|               |
  |        |         & Refresh Token      +---------------+
  |        |
  |        |                              +---------------+
  |        |--(C)----- Access Token ----->|               |
  |        |                              |               |
  |        |<-(D)-- Protected Resource ---|    Resource   |
  | Client |                              |     Server    |
  |        |--(E)----- Access Token ----->|               |
  |        |                              |               |
  |        |<-(F)-- Invalid Token Error --|               |
  |        |                              +---------------+
  |        |
  |        |          Refresh Token &     +---------------+
  |        |--(G)-- Client Credentials -->| Authorization |
  |        |                              |     Server    |
  |        |<-(H)----- Access Token ------|               |
  +--------+     & Optional Refresh Token +---------------+
]]>
            </artwork>
          </figure>
          <t>
            The refresh token flow illustrated in <xref target='Figure 4' /> includes the following
            steps:

            <list style='format (%C)'>
              <t>
                The client requests an access token by authenticating with the authorization server
                using its client credentials, and presenting an access grant.
              </t>
              <t>
                The authorization server validates the client credentials and the access grant, and
                if valid issues an access token and a refresh token.
              </t>
              <t>
                The client makes a protected resource requests to the resource server by presenting
                the access token.
              </t>
              <t>
                The resource server validates the access token, and if valid, serves the request.
              </t>
              <t>
                Steps (C) and (D) repeat until the access token expires. If the client does not
                know the access token expired, it makes another protected resource request.
                Otherwise, it skips to step (G).
              </t>
              <t>
                Since the access token is invalid (expired), the resource server returns an invalid
                token error.
              </t>
              <t>
                The client requests a new access token by authenticating with the authorization
                server using its client credentials, and presenting the refresh token (as the
                access grant).
              </t>
              <t>
                The authorization server validates the client credentials and the refresh token,
                and if valid issues a new access token (and optionally, a new refresh token).
              </t>
            </list>
          </t>
        </section>

        <section title='Assertion'>
          <t>
            Assertions provide a bridge between OAuth and other trust frameworks. They enable the
            client to utilize existing trust relationships in order to obtain an access token. The
            access grant represented by an assertion depends on the assertion type, its content,
            and how it was issued, which are beyond the scope of this specification.
          </t>
          <t>
            Assertions are used as part of the protocol extensibility model, providing a way for
            authorization servers to support additional access grant types.
          </t>
        </section>

      </section>

    </section>

    <section title='Client Profiles'>
      <t>
        
      </t>

      <section title='Web Server'>
        <t>
          The web server profile is suitable for clients capable of interacting with the end-user's
          user-agent (typically a web browser) and capable of receiving incoming requests (via
          redirection) from the authorization server (capable of acting as an HTTP server).
        </t>
        <figure title='Web Server Flow' anchor='Figure 6'>
          <artwork>
            <![CDATA[
  +----------+          Client Identifier      +---------------+
  |         -+----(A)--- & Redirect URI ------>|               |
  | End-user |                                 | Authorization |
  |    at    |<---(B)-- User authenticates --->|     Server    |
  | Browser  |                                 |               |
  |         -+----(C)-- Authorization Code ---<|               |
  +-|----|---+                                 +---------------+
    |    |                                         ^      v
   (A)  (C)                                        |      |
    |    |                                         |      |
    ^    v                                         |      |
  +---------+                                      |      |
  |         |>---(D)-- Client Credentials, --------'      |
  |  Server |          Authorization Code,                |
  |  -Based |            & Redirect URI                   |
  |  Client |                                             |
  |         |<---(E)----- Access Token -------------------'
  +---------+       (w/ Optional Refresh Token)
]]>
          </artwork>
        </figure>
        <t>
          The web server flow illustrated in <xref target='Figure 6' /> includes the following
          steps:

          <list style='format (%C)'>
            <t>
              The web client initiates the flow by redirecting the end-user's user-agent to the
              end-user authorization endpoint as described in <xref target='user-authorization' />.
              The client includes its client identifier, requested scope, local state, and a
              redirect URI to which the authorization server will send the end-user back once
              access is granted (or denied).
            </t>
            <t>
              The authorization server authenticates the end-user (via the user-agent) and
              establishes whether the end-user grants or denies the client's access request.
            </t>
            <t>
              Assuming the end-user granted access, the authorization server redirects the
              user-agent back to the client to the redirection URI provided earlier. The
              authorization includes an authorization code for the client to use to obtain an
              access token.
            </t>
            <t>
              The client requests an access token from the authorization server by authenticating
              and including the authorization code received in the previous step as described in
              <xref target='obtaining-token' />.
            </t>
            <t>
              The authorization server validates the client credentials and the authorization
              code and responds back with the access token.
            </t>
          </list>
        </t>
      </section>

      <section title='User-Agent' anchor='user-agent'>
        <t>
          The user-agent profile is suitable for client applications residing in a user-agent,
          typically implemented in a browser using a scripting language such as JavaScript. These
          clients cannot keep client secrets confidential and the authentication of the client is
          based on the user-agent's same-origin policy.
        </t>
        <t>
          Unlike other profiles in which the client makes separate requests for end-user
          authorization and access token, the client receives the access token as a result of the
          end-user authorization request in the form of an HTTP redirection. The client requests
          the authorization server to redirect the user-agent to another web server or local
          resource accessible to the user-agent which is capable of extracting the access token
          from the response and passing it to the client.
        </t>
        <t>
          This user-agent profile does not utilize the client secret since the client executables
          reside on the end-user's computer or device which makes the client secret accessible
          and exploitable. Because the access token is encoded into the redirection URI, it may
          be exposed to the end-user and other applications residing on the computer or device.
        </t>
        <figure title='User-Agent Flow' anchor='Figure 7'>
          <artwork>
            <![CDATA[
         +----------+          Client Identifier     +----------------+
         |          |>---(A)-- & Redirection URI --->|                |
         |          |                                |                |
  End <--+  -  -  - +----(B)-- User authenticates -->|  Authorization |
  User   |          |                                |     Server     |
         |          |<---(C)--- Redirect URI -------<|                |
         |  Client  |         with Access Token      |                |
         |    in    |            in Fragment         +----------------+
         |  Browser |
         |          |                                +----------------+
         |          |>---(D)--- Redirect URI ------->|                |
         |          |         without Fragment       |   Web Server   |
         |          |                                |   with Client  |
         |    (F)   |<---(E)--- Web Page with ------<|    Resource    |
         |  Access  |              Script            |                |
         |   Token  |                                +----------------+
         +----------+                                
]]>
          </artwork>
        </figure>
        <t>
          The user-agent flow illustrated in <xref target='Figure 7' /> includes the following
          steps:

          <list style='format (%C)'>
            <t>
              The client sends the user-agent to the end-user authorization endpoint as described
              in <xref target='user-authorization' />. The client includes its client identifier,
              requested scope, local state, and a redirect URI to which the authorization server
              will send the end-user back once authorization is granted (or denied).
            </t>
            <t>
              The authorization server authenticates the end-user (via the user-agent) and
              establishes whether the end-user grants or denies the client's access request.
            </t>
            <t>
              If the end-user granted access, the authorization server redirects the
              user-agent to the redirection URI provided earlier. The redirection URI includes
              the access token in the URI fragment.
            </t>
            <t>
              The user-agent follows the redirection instructions by making a request to the web
              server which does not include the fragment. The user-agent retains the fragment
              information locally.
            </t>
            <t>
              The web server returns a web page  (typically an HTML page with an embedded script)
              capable of accessing the full redirection URI including the fragment retained by the
              user-agent, and extracting the access token (and other parameters) contained in the
              fragment.
            </t>
            <t>
              The user-agent executes the script provided by the web server locally, which
              extracts the access token and passes it to the client.
            </t>
          </list>
        </t>
      </section>

      <section title='Native Application'>
        <t>
          Native applications are clients running as native code on the end-user's computer or
          device (i.e. executing outside a user-agent or as a desktop program). These clients are
          often capable of interacting with (or embedding) the end-user's user-agent but are
          limited in how such interaction affects their end-user experience. In many cases,
          native applications are incapable of receiving direct callback requests from the
          server (e.g. firewall, operating system restrictions).
        </t>
        <t>
          Native application clients can be implemented in different ways based on their
          requirements and desired end-user experience. Native application clients can:

          <list style='symbols'>
            <t>
              Utilize the end-user authorization endpoint as described in
              <xref target='user-authorization' /> by launching an external user-agent. The
              client can capture the response by providing a redirection URI with a custom URI
              scheme (registered with the operating system to invoke the client application), or
              by providing a redirection URI pointing to a server-hosted resource under the
              client's control which makes the response available to the client (e.g. using the
              window title or other locations accessible from outside the user-agent).
            </t>
            <t>
              Utilize the end-user authorization endpoint as described in
              <xref target='user-authorization' /> by using an embedded user-agent. The client
              obtains the response by directly communicating with the embedded user-agent.
            </t>
            <t>
              Prompt end-users for their password and use them directly to obtain an access
              token. This is generally discouraged, as it hands the end-user's password directly
              to the third-party client which in turn has to store it in clear-text. It also
              requires the server to support password-based authentication.
            </t>
          </list>
        </t>
        <t>
          When choosing between launching an external browser and an embedded user-agent,
          developers should consider the following:

          <list style='symbols'>
            <t>
              External user-agents may improve completion rate as the end-user may already be
              logged-in and not have to re-authenticate.
            </t>
            <t>
              Embedded user-agents often offer a better end-user flow, as they remove the need to
              switch context and open new windows.
            </t>
            <t>
              Embedded user-agents pose a security challenge because users are authenticating in
              an unidentified window without access to the visual protections offered by many
              user-agents.
            </t>
          </list>
        </t>
      </section>

      <section title='Autonomous'>
        <t>
          Autonomous clients utilize an existing trust relationship or framework to establish
          authorization. Autonomous clients can be implemented in different ways based on their
          requirements and the existing trust framework they rely upon. Autonomous clients can:

          <list style='symbols'>
            <t>
              Obtain an access token by authenticating with the authorization server using their
              client credentials. The scope of the access token is limited to the protected
              resources under the control of the client, or that of another resource owner
              previously arranged with the authorization server.
            </t>
            <t>
              Use an existing access grant expressed as an assertion using an assertion format
              supported by the authorization server. Using assertions requires the client to
              obtain an assertion (such as a <xref target='OASIS.saml-core-2.0-os'>SAML</xref>
              assertion) from an assertion issuer or to self-issue an assertion. The assertion
              format, the process by which the assertion is obtained, and the method of
              validating the assertion are defined by the assertion issuer and the authorization
              server, and are beyond the scope of this specification.
            </t>
          </list>
        </t>
      </section>

    </section>

    <section title='Client Credentials' anchor='client-authentication'>
      <t>
        When interacting with the authorization server, the client identifies itself using a set of
        client credentials which include a client identifier and other properties for client
        authentication. The means through which the client obtains its credentials are beyond the
        scope of this specification, but typically involve registration with the authorization
        server.
      </t>
      <t>
        Due to the nature of some clients, authorization servers SHOULD NOT make assumptions
        about the confidentiality of client secrets without establishing trust with the
        client operator. Authorization servers SHOULD NOT issue client secrets to clients
        incapable of keeping their secrets confidential.
      </t>
      <t>
        The authorization server MAY authenticate the client using any appropriate set of
        credentials and authentication schemes. The client MUST NOT include more than one set of
        credentials or authentication mechanism with each request.
      </t>

      <section title='Client Password Credentials'>
        <t>
          The client password credentials use a shared symmetric secret to authenticate the client.
          The client identifier and password are included in the request using the
          HTTP Basic authentication scheme as defined in <xref target='RFC2617' /> by including the
          client identifier as the username and client password as the password.
        </t>
        <figure>
          <preamble>
            For example (line breaks are for display purposes only):
          </preamble>
          <artwork>
            <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded

  grant_type=authorization_code&code=i1WsRn1uB1&
  redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
]]>
          </artwork>
        </figure>
        <t>
          Alternatively, the client MAY include the password in the request body using the
          following parameters:

          <list style='hanging' hangIndent='6'>
            <t hangText='client_id'>
              <vspace />
              REQUIRED. The client identifier.
            </t>
            <t hangText='client_secret'>
              REQUIRED. The client password.
            </t>
          </list>
        </t>
        <figure>
          <preamble>
            For example (line breaks are for display purposes only):
          </preamble>
          <artwork>
            <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  grant_type=authorization_code&client_id=s6BhdRkqt3&
  client_secret=gX1fBat3bV&code=i1WsRn1uB1&
  redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
]]>
          </artwork>
        </figure>
        <t>
          The authorization server MUST accept the client credentials using both the request
          parameter, and the HTTP Basic authentication scheme. The authorization server MAY
          support additional authentication schemes suitable for the transmission of password
          credentials.
        </t>
      </section>

      <section title='Client Assertion Credentials'>
        <t>
          The client assertion credentials are used in cases where a password (clear-text shared
          symetric secret) is unsuitable or does not provide sufficient security for client
          authentication. In such cases it is common to use other mechanisms such as HMAC or
          digital signatures that do not require sending clear-text secrets. The client assertion
          credentials provide an extensible mechanism to use an assertion format supported by the
          authorization server for authentication the client.
        </t>
        <t>
          Using assertions requires the client to obtain an assertion (such as a
          <xref target='OASIS.saml-core-2.0-os'>SAML</xref> assertion) from an assertion issuer or
          to self-issue an assertion. The assertion format, the process by which the assertion is
          obtained, and the method of validating the assertion are defined by the assertion issuer
          and the authorization server, and are beyond the scope of this specification.
        </t>
        <t>
          When using a client assertion, the client includes the following parameters:

          <list style='hanging' hangIndent='6'>
            <t hangText='client_assertion_type'>
              REQUIRED. The format of the assertion as defined by the authorization server. The value
              MUST be an absolute URI.
            </t>
            <t hangText='client_assertion'>
              REQUIRED. The client assertion.
            </t>
          </list>
        </t>
        <figure>
          <preamble>
            For example, the client sends the following access token request using a SAML 2.0
            assersion to authenticate itself (line breaks are for display purposes only):
          </preamble>
          <artwork>
            <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  grant_type=authorization_code&code=i1WsRn1uB1&
  client_assertion=PHNhbWxwOl[...omitted for brevity...]ZT4%3D&
  client_assertion_type=
  urn%3Aoasis%3Anames%sAtc%3ASAML%3A2.0%3Aassertion&
  redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
]]>
          </artwork>
        </figure>
        <t>
          When obtaining an access token using a client assertion together with an authorization code
          (as described in <xref target='code-grant-type' />), a mechanism is needed to map between the
          value of <spanx style='verb'>client_id</spanx> parameter used to obtain the authorization code,
          and the client assertion. Such mechanism is beyond the out of scope for this specification,
          but MUST be specified for any client assertion type used in combination with an authorization
          code.
        </t>
        <t>
          The authorization server MUST reject access token requests using client assertion credentials
          that do not contain HMAC or signed values that:

          <list style='symbols'>
            <t>
              State the assertion was specifically issued to be consumed by the receiving endpoint
              (typically via an audience or recipient value containing the receiving endpoint’s
              identifier).
            </t>
            <t>
              Identify the entity that issued the assertion (typically via an issuer value).
            </t>
            <t>
              Identify when the assertion expires as an absolute time (typically via an expiration
              value containing a UTC date/time value). The authorization server MUST reject expired
              assertions.
            </t>
          </list>
        </t>
      </section>

    </section>

    <section title='Obtaining End-User Authorization' anchor='user-authorization'>
      <t>
        Before the client can access a protect resource, it MUST first obtain authorization from
        the end-user. To obtain an end-user authorization, the client sends the end-user to the
        end-user authorization endpoint. Once obtained, the end-user access grant is expressed as
        an authorization code which the client uses to obtain an access token.
      </t>
      <t>
        At the end-user authorization endpoint, the end-user first authenticates with the
        authorization server, and then grants or denies the access request. The way in which the
        authorization server authenticates the end-user (e.g. username and password login, OpenID,
        session cookies) and in which the authorization server obtains the end-user's
        authorization, including whether it uses a secure channel such as TLS, is beyond the scope
        of this specification. However, the authorization server MUST first verify the identity of
        the end-user.
      </t>
      <t>
        The location of the end-user authorization endpoint can be found in the service
        documentation. The end-user authorization endpoint URI MAY include a query component as
        defined by <xref target='RFC3986' /> section 3, which must be retained when adding
        additional query parameters.
      </t>
      <t>
        Since requests to the end-user authorization endpoint result in user authentication and
        the transmission of sensitive information, the authorization server SHOULD require the
        use of a transport-layer security mechanism such as TLS when sending requests to the
        end-user authorization endpoint.
      </t>

      <section title='Authorization Request'>
        <t>
          In order to direct the end-user's user-agent to the authorization server, the client
          constructs the request URI by adding the following parameters to the end-user
          authorization endpoint URI query component using the
          <spanx style='verb'>application/x-www-form-urlencoded</spanx> format as defined by
          <xref target='W3C.REC-html401-19991224' />:

          <list style='hanging' hangIndent='6'>
            <t hangText='response_type'>
              <vspace />
              REQUIRED. The requested response: an access token, an authorization code, or both. The
              parameter value MUST be set to <spanx style='verb'>token</spanx> for requesting an
              access token, <spanx style='verb'>code</spanx> for requesting an authorization code, or
              <spanx style='verb'>code_and_token</spanx> to request both. The authorization server
              MAY decline to provide one or more of these response types.
            </t>
            <t hangText='client_id'>
              <vspace />
              REQUIRED. The client identifier as described in
              <xref target='client-authentication' />.
            </t>
            <t hangText='redirect_uri'>
              <vspace />
              REQUIRED, unless a redirection URI has been established between the client and
              authorization server via other means. An absolute URI to which the authorization
              server will redirect the user-agent to when the end-user authorization step is
              completed. The authorization server SHOULD require the client to pre-register
              their redirection URI.
            </t>
            <t hangText='scope'>
              <vspace />
              OPTIONAL. The scope of the access request expressed as a list of space-delimited
              strings. The value of the <spanx style='verb'>scope</spanx> parameter is defined
              by the authorization server. If the value contains multiple space-delimited
              strings, their order does not matter, and each string adds an additional access
              range to the requested scope.
            </t>
            <t hangText='state'>
              <vspace />
              OPTIONAL. An opaque value used by the client to maintain state between the request
              and callback. The authorization server includes this value when redirecting the
              user-agent back to the client.
            </t>
          </list>
        </t>
        <t>
          The client directs the end-user to the constructed URI using an HTTP redirection
          response, or by other means available to it via the end-user's user-agent. The
          authorization server MUST support the use of the HTTP <spanx style='verb'>GET</spanx>
          method for the end-user authorization endpoint, and MAY support the use of the
          <spanx style='verb'>POST</spanx> method as well.
        </t>
        <figure>
          <preamble>
            For example, the client directs the end-user's user-agent to make the following HTTP
            request using transport-layer security (line breaks are for display purposes only):
          </preamble>
          <artwork>
            <![CDATA[
  GET /authorize?response_type=code&client_id=s6BhdRkqt3&
      redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
  Host: server.example.com
]]>
          </artwork>
        </figure>
        <t>
          If the client has previously registered a redirection URI with the authorization server,
          the authorization server MUST verify that the redirection URI received matches the
          registered URI associated with the client identifier. The authorization server SHOULD
          NOT redirect the user-agent to unregistered or untrusted URIs to prevent the endpoint
          from being used as an open redirector. If no valid redirection URI is available, the
          authorization server SHOULD inform the end-user of the error occured.
          [[ provide guidance on how to perform matching ]]
        </t>
        <t>
          Parameters sent without a value MUST be treated as if they were omitted from the request.
          The authorization server SHOULD ignore unrecognized request parameters.
        </t>
        <t>
          The authorization server validates the request to ensure all required parameters are
          present and valid. If the request is invalid, the authorization server redirects the
          user-agent back to the client using the redirection URI provided with the appropriate
          error code as described in <xref target='auth-error' />.
        </t>
        <t>
          The authorization server authenticates the end-user and obtains an authorization
          decision (by asking the end-user or by establishing approval via other means). When a
          decision has been established, the authorization server directs the end-user's
          user-agent to the provided client redirection URI using an HTTP redirection response,
          or by other means available to it via the end-user's user-agent.
        </t>
      </section>

      <section title='Authorization Response'>
        <t>
          If the end-user grants the access request, the authorization server issues an access
          token, an authorization code, or both, and delivers them to the client by adding the
          following parameters to the redirection URI (as described below):

          <list style='hanging' hangIndent='6'>
            <t hangText='code'>
              <vspace />
              REQUIRED if the response type is <spanx style='verb'>code</spanx> or
              <spanx style='verb'>code_and_token</spanx>, otherwise MUST NOT be included. The
              authorization code generated by the authorization server. The authorization code
              SHOULD expire shortly after it is issued to minimize the risk of leaks. The client
              MUST NOT reuse the authorization code. If an authorization code is used more than
              once, the authorization server MAY revoke all tokens previously issued based on that
              authorization code. The authorization code is bound to the client identifier and
              redirection URI.
            </t>
            <t hangText='access_token'>
              <vspace />
              REQUIRED if the response type is <spanx style='verb'>token</spanx> or
              <spanx style='verb'>code_and_token</spanx>, otherwise MUST NOT be included. The
              access token issued by the authorization server.
            </t>
            <t hangText='token_type'>
              <vspace />
              REQUIRED if the response includes an access token. The type of the token issued.
              The token type informs the client how the access token is to be used when accessing a
              protected resource as described in <xref target='token-types' />.
            </t>
            <t hangText='expires_in'>
              <vspace />
              OPTIONAL. The duration in seconds of the access token lifetime if an access token
              is included. For example, the value <spanx style='verb'>3600</spanx> denotes that the
              access token will expire in one hour from the time the response was generated by the
              authorization server.
            </t>
            <t hangText='scope'>
              <vspace />
              OPTIONAL. The scope of the access token as a list of space-delimited strings if an
              access token is included. The value of the <spanx style='verb'>scope</spanx>
              parameter is defined by the authorization server. If the value contains multiple
              space-delimited strings, their order does not matter, and each string adds an
              additional access range to the requested scope. The authorization server SHOULD
              include the parameter if the requested scope is different from the one requested by
              the client.
            </t>
            <t hangText='state'>
              <vspace />
              REQUIRED if the <spanx style='verb'>state</spanx> parameter was present in the
              client authorization request. Set to the exact value received from the client.
            </t>
          </list>
        </t>
        <t>
          The method in which the authorization server adds the parameter to the redirection
          URI is determined by the response type requested by the client in the authorization
          request using the <spanx style='verb'>response_type</spanx> parameter.
        </t>
        <t>
          If the response type is <spanx style='verb'>code</spanx>, the authorization
          server adds the parameters to the redirection URI query component using the
          <spanx style='verb'>application/x-www-form-urlencoded</spanx> format as defined by
          <xref target='W3C.REC-html401-19991224' />.
        </t>
        <figure>
          <preamble>
            For example, the authorization server redirects the end-user's user-agent by
            sending the following HTTP response:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 302 Found
  Location: https://client.example.com/cb?code=i1WsRn1uB1
]]>
          </artwork>
        </figure>
        <t>
          If the response type is <spanx style='verb'>token</spanx> or
          <spanx style='verb'>code_and_token</spanx>, the authorization server adds the parameters
          to the redirection URI fragment component using the
          <spanx style='verb'>application/x-www-form-urlencoded</spanx> format as defined by
          <xref target='W3C.REC-html401-19991224' />.
        </t>
        <figure>
          <preamble>
            For example, the authorization server redirects the end-user's user-agent by
            sending the following HTTP response (URI line breaks are for display purposes only):
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 302 Found
  Location: http://example.com/rd#access_token=FJQbwq9&token_type=bearer
            &expires_in=3600
]]>
          </artwork>
        </figure>
        <t>
          Clients SHOULD ignore unrecognized response parameters. The sizes of tokens and other
          values received from the authorization server, are left undefined by this specification.
          Clients should avoid making assumptions about value sizes. Servers should document the
          expected size of any value they issue.
        </t>
      </section>

      <section title='Error Response' anchor='auth-error'>
        <t>
          If the end-user denies the access request or if the request is invalid, the authorization
          server informs the client by adding the following parameters to the redirection URI query
          component using the <spanx style='verb'>application/x-www-form-urlencoded</spanx> format
          as defined by <xref target='W3C.REC-html401-19991224' />:

          <list style='hanging' hangIndent='6'>
            <t hangText='error'>
              <vspace />
              REQUIRED. A single error code as described in <xref target='auth-error-codes' />.
            </t>
            <t hangText='error_description'>
              OPTIONAL. A human-readable text providing additional information, used to assist in
              the understanding and resolution of the error occurred.
            </t>
            <t hangText='error_uri'>
              OPTIONAL. A URI identifying a human-readable web page with information about the
              error, used to provide the end-user with additional information about the error.
            </t>
            <t hangText='state'>
              <vspace />
              REQUIRED if the <spanx style='verb'>state</spanx> parameter was present in the
              client authorization request. Set to the exact value received from the client.
            </t>
          </list>
        </t>
        <figure>
          <preamble>
            For example, the authorization server redirects the end-user's user-agent by
            sending the following HTTP response:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 302 Found
  Location: https://client.example.com/cb?error=access_denied
]]>
          </artwork>
        </figure>

        <section title='Error Codes' anchor='auth-error-codes'>
          <t>
            The authorization server includes one of the following error codes with the error
            response:

            <list style='hanging' hangIndent='6'>
              <t hangText='invalid_request'>
                <vspace />
                The request is missing a required parameter, includes an unsupported parameter or
                parameter value, or is otherwise malformed.
              </t>
              <t hangText='invalid_client'>
                <vspace />
                The client identifier provided is invalid.
              </t>
              <t hangText='unauthorized_client'>
                <vspace />
                The client is not authorized to use the requested response type.
              </t>
              <t hangText='redirect_uri_mismatch'>
                <vspace />
                The redirection URI provided does not match a pre-registered value.
              </t>
              <t hangText='access_denied'>
                <vspace />
                The end-user or authorization server denied the request.
              </t>
              <t hangText='unsupported_response_type'>
                <vspace />
                The requested response type is not supported by the authorization server.
              </t>
              <t hangText='invalid_scope'>
                <vspace />
                The requested scope is invalid, unknown, or malformed.
              </t>
            </list>
          </t>
          <t>
            [[ Add mechanism for extending error codes ]]
          </t>
        </section>

      </section>

    </section>

    <section title='Obtaining an Access Token' anchor='obtaining-token'>
      <t>
        The client obtains an access token by authenticating with the authorization server and
        presenting its access grant (in the form of an authorization code, resource owner
        credentials, an assertion, or a refresh token).
      </t>
      <t>
        Since requests to the token endpoint result in the transmission of clear-text
        credentials in the HTTP request and response, the authorization server MUST require the
        use of a transport-layer security mechanism when sending requests to the token endpoints.
        Servers MUST support TLS 1.2 as defined in <xref target='RFC5246' />, and MAY support
        additional transport-layer security mechanisms.
      </t>
      <t>
        The client requests an access token by making an HTTP <spanx style='verb'>POST</spanx>
        request to the token endpoint. The location of the token endpoint can be found in the
        service documentation. The token endpoint URI MAY include a query component.
      </t>
      <t>
        The client authenticates with the authorization server by adding its client credentials to
        the request as described in <xref target='client-authentication' />. The authorization
        server MAY allow unauthenticated access token requests when the client identity does not
        matter (e.g. anonymous client) or when the client identity is established via other means
        (e.g. using an assertion access grant).
      </t>
      <t>
        The client constructs the request by including the following parameters using the
        <spanx style='verb'>application/x-www-form-urlencoded</spanx> format in the HTTP request
        entity-body:

        <list style='hanging' hangIndent='6'>
          <t hangText='grant_type'>
            <vspace />
            REQUIRED. The access grant type included in the request. Value MUST be one of
            <spanx style='verb'>authorization_code</spanx>,
            <spanx style='verb'>password</spanx>,
            <spanx style='verb'>refresh_token</spanx>,
            <spanx style='verb'>client_credentials</spanx>, or an absolute URI identifying an
            assertion format supported by the authorization server.
          </t>
          <t hangText='scope'>
            <vspace />
            OPTIONAL. The scope of the access request expressed as a list of space-delimited
            strings. The value of the <spanx style='verb'>scope</spanx> parameter is defined
            by the authorization server. If the value contains multiple space-delimited
            strings, their order does not matter, and each string adds an additional access
            range to the requested scope. If the access grant being used already represents an
            approved scope (e.g. authorization code, assertion), the requested scope MUST be equal
            or lesser than the scope previously granted.
          </t>
        </list>
      </t>
      <t>
        In addition, the client MUST include the appropriate parameters listed for the selected
        access grant type as described in <xref target='access-grant-types' />.
      </t>
      <t>
        Parameters sent without a value MUST be treated as if they were omitted from the request.
        The authorization server SHOULD ignore unrecognized request parameters.
      </t>

      <section title='Access Grant Types' anchor='access-grant-types'>
        <t>
          The client requests an access token using an authorization code, resource owner password
          credentials, client credentials, refresh token, or assertion.
        </t>

        <section title='Authorization Code' anchor='code-grant-type'>
          <t>
            The client includes the authorization code using the
            <spanx style='verb'>authorization_code</spanx> access grant type and the following
            parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='code'>
                <vspace />
                REQUIRED. The authorization code received from the authorization server.
              </t>
              <t hangText='redirect_uri'>
                <vspace />
                REQUIRED. The redirection URI used in the initial request.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTP request by including its client
              credentials via the <spanx style='verb'>client_secret</spanx> parameter described in
              <xref target='client-authentication' /> and using transport-layer security (line
              breaks are for display purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  grant_type=authorization_code&client_id=s6BhdRkqt3&
  client_secret=gX1fBat3bV&code=i1WsRn1uB1&
  redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST:

            <list style='symbols'>
              <t>
                Validate the client credentials (if present) and ensure they match the
                authorization code.
              </t>
              <t>
                Verify that the authorization code and redirection URI are all valid and match its
                stored association.
              </t>
            </list>
          </t>
          <t>
            If the request is valid, the authorization server issues a successful response as
            described in <xref target='access-token-response' />.
          </t>
        </section>

        <section title='Resource Owner Password Credentials'>
          <t>
            The client includes the resource owner credentials using the
            <spanx style='verb'>password</spanx> access grant type and the following
            parameters: [[ add internationalization consideration for username and password ]]

            <list style='hanging' hangIndent='6'>
              <t hangText='username'>
                <vspace />
                REQUIRED. The resource owner's username.
              </t>
              <t hangText='password'>
                <vspace />
                REQUIRED. The resource owner's password.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTP request by including its client
              credentials via the <spanx style='verb'>client_secret</spanx> parameter described in
              <xref target='client-authentication' /> and using transport-layer security (line
              breaks are for display purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded
  
  grant_type=password&client_id=s6BhdRkqt3&
  client_secret=47HDu8s&username=johndoe&password=A3ddj3w
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST validate the client credentials (if present) and end-user
            credentials and if valid issue an access token response as described in
            <xref target='access-token-response' />.
          </t>
        </section>

        <section title='Client Credentials'>
          <t>
            The client can request an access token using only its client credentials using the
            <spanx style='verb'>client_credentials</spanx> access grant type. When omitting an
            explicit access grant, the client is requesting access to the protected resources under
            its control, or those of another resource owner which has been previously arranged with
            the authorization server (the method of which is beyond the scope of this
            specification).
          </t>
        </section>

        <section title='Refresh Token' anchor='token-refresh'>
          <t>
            The client includes the refresh token using the
            <spanx style='verb'>refresh_token</spanx> access grant type and the following
            parameter:

            <list style='hanging' hangIndent='6'>
              <t hangText='refresh_token'>
                <vspace />
                REQUIRED. The refresh token associated with the access token to be refreshed.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTP request by including its client
              credentials via the <spanx style='verb'>client_secret</spanx> parameter described in
              <xref target='client-authentication' /> and using transport-layer security (line
              breaks are for display purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded
  
  grant_type=refresh_token&client_id=s6BhdRkqt3&
  client_secret=8eSEIpnqmM&refresh_token=n4E9O119d
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST verify the client credentials (if present), the validity
            of the refresh token, and that the resource owner's authorization is still valid. If
            the request is valid, the authorization server issues an access token response as
            described in <xref target='access-token-response' />. The authorization server MAY
            issue a new refresh token, in which case, the client MUST discard the old refresh
            token and replace it with the new refresh token.
          </t>
        </section>

        <section title='Assertion'>
          <t>
            The client includes an assertion by specifying the assertion format using an abolute
            URI (as defined by the authorization server) as the value of the
            <spanx style='verb'>grant_type</spanx> parameter and by adding the following parameter:

            <list style='hanging' hangIndent='6'>
              <t hangText='assertion'>
                <vspace />
                REQUIRED. The assertion.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTP request using transport-layer
              security, and client authentication is achieved via the assertion (line breaks are
              for display purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded
  
  grant_type=urn%3Aoasis%3Anames%3Atc%3ASAML%3A2.0%3Aassertion&
  assertion=PHNhbWxwOl[...omitted for brevity...]ZT4%3D
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST validate the client credentials (if present) and the
            assertion and if valid issues an access token response as described in
            <xref target='access-token-response' />. The authorization server SHOULD NOT issue a
            refresh token (instead, it should require the client to use the same or new assertion).
          </t>
          <t>
            Authorization servers SHOULD issue access tokens with a limited lifetime and require
            clients to refresh them by requesting a new access token using the same assertion if it
            is still valid. Otherwise the client MUST obtain a new valid assertion.
          </t>
        </section>

      </section>

      <section title='Access Token Response' anchor='access-token-response'>
        <t>
          After receiving and verifying a valid and authorized access token request from the
          client, the authorization server issues the access token and optional refresh token,
          and constructs the response by adding the following parameters to the entity body of
          the HTTP response with a 200 (OK) status code:
        </t>
        <t>
          The token response contains the following parameters:

          <list style='hanging' hangIndent='6'>
            <t hangText='access_token'>
              <vspace />
              REQUIRED. The access token issued by the authorization server.
            </t>
            <t hangText='token_type'>
              <vspace />
              REQUIRED. The type of the token issued. The token type informs the client how the
              access token is to be used when accessing a protected resource as described in
              <xref target='token-types' />.
            </t>
            <t hangText='expires_in'>
              <vspace />
              OPTIONAL. The duration in seconds of the access token lifetime. For example, the
              value <spanx style='verb'>3600</spanx> denotes that the access token will expire in
              one hour from the time the response was generated by the authorization server.
            </t>
            <t hangText='refresh_token'>
              <vspace />
              OPTIONAL. The refresh token used to obtain new access tokens using the same
              end-user access grant as described in <xref target='token-refresh' />. The
              authorization server SHOULD NOT issue a refresh token when the access grant type is
              an assertion or a set of client credentials.
            </t>
            <t hangText='scope'>
              <vspace />
              OPTIONAL. The scope of the access token as a list of space-delimited strings. The
              value of the <spanx style='verb'>scope</spanx> parameter is defined by the
              authorization server. If the value contains multiple space-delimited strings,
              their order does not matter, and each string adds an additional access range to
              the requested scope. The authorization server SHOULD include the parameter if the
              requested scope is different from the one requested by the client.
            </t>
          </list>
        </t>
        <t>
          The parameters are including in the entity body of the HTTP response using the
          <spanx style='verb'>application/json</spanx> media type as defined by
          <xref target='RFC4627' />. The parameters are serialized into a JSON structure by
          adding each parameter at the highest structure level. Parameter names and string values
          are included as JSON strings. Numerical values are included as JSON numbers.
        </t>
        <t>
          The authorization server MUST include the HTTP <spanx style='verb'>Cache-Control</spanx>
          response header field with a value of <spanx style='verb'>no-store</spanx> in any
          response containing tokens, secrets, or other sensitive information.
        </t>
        <figure>
          <preamble>
            For example:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json
  Cache-Control: no-store

  {
    "access_token":"SlAV32hkKG",
    "token_type":"bearer",
    "expires_in":3600,
    "refresh_token":"8xLOxBtZp8"
  }
]]>
          </artwork>
        </figure>
        <t>
          Clients SHOULD ignore unrecognized response parameters. The sizes of tokens and other
          values received from the authorization server, are left undefined by this specification.
          Clients should avoid making assumptions about value sizes. Servers should document the
          expected size of any value they issue.
        </t>
      </section>

      <section title='Error Response' anchor='token-error'>
        <t>
          If the token request is invalid or unauthorized, the authorization server constructs
          the response by adding the following parameter to the entity body of the HTTP
          response using the <spanx style='verb'>application/json</spanx> media type:

          <list style='hanging' hangIndent='6'>
            <t hangText='error'>
              <vspace />
              REQUIRED. A single error code as described in <xref target='token-error-codes' />.
            </t>
            <t hangText='error_description'>
              OPTIONAL. A human-readable text providing additional information, used to assist in
              the understanding and resolution of the error occurred.
            </t>
            <t hangText='error_uri'>
              OPTIONAL. A URI identifying a human-readable web page with information about the
              error, used to provide the end-user with additional information about the error.
            </t>
          </list>
        </t>
        <figure>
          <preamble>
            For example:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 400 Bad Request
  Content-Type: application/json
  Cache-Control: no-store

  {
    "error":"invalid_request"
  }
]]>
          </artwork>
        </figure>
        <t>
          If the client provided invalid credentials using an HTTP authentication scheme via the
          <spanx style='verb'>Authorization</spanx> request header field, the authorization server
          MUST respond with the HTTP 401 (Unauthorized) status code. Otherwise, the authorization
          server SHALL respond with the HTTP 400 (Bad Request) status code.
        </t>

        <section title='Error Codes' anchor='token-error-codes'>
          <t>
            The authorization server includes one of the following error codes with the error
            response:

            <list style='hanging' hangIndent='6'>
              <t hangText='invalid_request'>
                <vspace />
                The request is missing a required parameter, includes an unsupported parameter or
                parameter value, repeats a parameter, includes multiple credentials, utilizes
                more than one mechanism for authenticating the client, or is otherwise malformed.
              </t>
              <t hangText='invalid_client'>
                <vspace />
                The client identifier provided is invalid, the client failed to authenticate, the
                client did not include its credentials, provided multiple client credentials, or
                used unsupported credentials type.
              </t>
              <t hangText='unauthorized_client'>
                <vspace />
                The authenticated client is not authorized to use the access grant type provided.
              </t>
              <t hangText='invalid_grant'>
                <vspace />
                The provided access grant is invalid, expired, or revoked (e.g. invalid assertion,
                expired authorization token, bad end-user password credentials, or mismatching
                authorization code and redirection URI).
              </t>
              <t hangText='unsupported_grant_type'>
                <vspace />
                The access grant included - its type or another attribute - is not supported by the
                authorization server.
              </t>
              <t hangText='invalid_scope'>
                <vspace />
                The requested scope is invalid, unknown, malformed, or exceeds the previously
                granted scope.
              </t>
            </list>
          </t>
          <t>
            [[ Add mechanism for extending error codes ]]
          </t>
        </section>

      </section>

    </section>

    <section title='Accessing a Protected Resource' anchor='access-resource'>
      <t>
        Clients access protected resources by presenting an access token to the resource server.
        The resource server MUST validate the access token and ensure it has not expired and
        that its scope covers the requested resource. The methods used by the resource server
        to validate the access token are beyond the scope of this specification, but generally
        involve an interaction or coordination between the resource server and authorization
        server.
      </t>

      <section title='Access Token Types' anchor='token-types'>
        <t>
          
        </t>
      </section>

      <section title='The WWW-Authenticate Response Header Field' anchor='authn-header'>
        <t>
          If the protected resource request contains an invalid access token or is malformed, the
          resource server MUST include the HTTP <spanx style='verb'>WWW-Authenticate</spanx>
          response header field. The <spanx style='verb'>WWW-Authenticate</spanx> header field
          uses the framework defined by <xref target='RFC2617' /> as follows:
        </t>
        <figure>
          <artwork>
            <![CDATA[
  challenge       = "OAuth2" RWS token-challenge

  token-challenge = [ CS error ]
                    [ CS error-desc ]
                    [ CS error-uri ]
                    [ CS scope ]
                    [ CS 1#auth-param ]
                    
  error           = "error" "=" <"> token <">
  error-desc      = "error_description" "=" quoted-string
  error-uri       = "error_uri" = <"> URI-Reference <">
  scope           = quoted-value /
                    <"> quoted-value *( 1*SP quoted-value ) <">
  quoted-value    = 1*quoted-char
    
  CS              = OWS "," OWS

  credentials    = "OAuth" RWS access-token [ RWS 1#auth-param ]
  access-token   = 1*( quoted-char / <"> )

  quoted-char    =   "!" / "#" / "$" / "%" / "&" / "'" / "("
                   / ")" / "*" / "+" / "-" / "." / "/" / DIGIT
                   / ":" / "<" / "=" / ">" / "?" / "@" / ALPHA
                   / "[" / "]" / "^" / "_" / "`" / "{" / "|"
                   / "}" / "~" / "\" / "," / ";"
]]>
          </artwork>
        </figure>
        <figure>
          <preamble>
            For example:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 401 Unauthorized
  WWW-Authenticate: OAuth2
                    error="invalid_token",
                    error_description="The access token expired"
]]>
          </artwork>
        </figure>
        <t>
          The <spanx style='verb'>error</spanx> attribute is used to provide the client with the
          reason why the access request was declined. The parameter values are described in
          <xref target='resource-error-codes' />.
        </t>
        <t>
          The <spanx style='verb'>error_description</spanx> attribute provides a human-readable
          text containing additional information, used to assist in the understanding and
          resolution of the error occurred.
        </t>
        <t>
          The <spanx style='verb'>error_uri</spanx> attribute provides an absolute URI identifying
          a human-readable web page with information about the error, used to offer the end-user
          with additional information about the error. If the value is not an absolute URI, it is
          relative to the URI of the requested protected resource.
        </t>
        <t>
          The <spanx style='verb'>scope</spanx> attribute is a space-delimited list of scope values
          indicating the required scope of the access token for accessing the requested resource.
        </t>

        <section title='Error Codes' anchor='resource-error-codes'>
          <t>
            When a request fails, the resource server responds using the appropriate HTTP status
            code (typically, 400, 401, or 403), and includes one of the following error codes in
            the response:

            <list style='hanging' hangIndent='6'>
              <t hangText='invalid_request'>
                <vspace />
                The request is missing a required parameter, includes an unsupported parameter or
                parameter value, repeats the same parameter, uses more than one method for
                including an access token, or is otherwise malformed. The resource server SHOULD
                respond with the HTTP 400 (Bad Request) status code.
              </t>
              <t hangText='invalid_token'>
                <vspace />
                The access token provided is expired, revoked, malformed, or invalid for other
                reasons. The resource SHOULD respond with the HTTP 401 (Unauthorized) status
                code. The client MAY request a new access token and retry the protected resource
                request.
              </t>
              <t hangText='insufficient_scope'>
                <vspace />
                The request requires higher privileges than provided by the access token. The
                resource server SHOULD respond with the HTTP 403 (Forbidden) status code and MAY
                include the <spanx style='verb'>scope</spanx> attribute with the scope necessary to
                access the protected resource.
              </t>
            </list>
          </t>
          <t>
            [[ Add mechanism for extending error codes ]]
          </t>
          <t>
            If the request lacks any authentication information (i.e. the client was unaware
            authentication is necessary or attempted using an unsupported authentication method),
            the resource server SHOULD not include an error code or other error information.
          </t>
          <figure>
            <preamble>
              For example:
            </preamble>
            <artwork>
              <![CDATA[
  HTTP/1.1 401 Unauthorized
  WWW-Authenticate: OAuth2
]]>
            </artwork>
          </figure>
        </section>

      </section>

    </section>

    <section title='Extensibility'>

      <section title='Defining New Client Credentials Types'>
        <t>
          [[ TBD ]]
        </t>
      </section>

      <section title='Defining New Endpoint Parameters'>
        <t>
          Applications that wish to define new request or response parameters for use with the
          end-user authorization endpoint or the token endpoint SHALL do so in one of two ways:
          register them in the parameters registry (following the procedures in
          <xref target='parameters-registry' />), or use the <spanx style='verb'>x_</spanx>
          parameter name prefix.
        </t>
        <t>
          Parameters utilizing the <spanx style='verb'>x_</spanx> parameter name prefix MUST be
          limited to vendor-specific extensions that are not commonly applicable, and are specific
          to the implementation details of the authorization server where they are used. All other
          new parameters MUST be registered, and MUST NOT use the <spanx style='verb'>x_</spanx>
          parameter name prefix.
        </t>
        <t>
          Parameter names MUST conform to the param-name ABNF, and parameter values syntax MUST be
          well-defined (e.g., using ABNF, or a reference to the syntax of an existing parameter).
        </t>
        <figure>
          <artwork>
            <![CDATA[
  param-name  = 1*name-char
  name-char   = "-" / "." / "_" / DIGIT / ALPHA
]]>
          </artwork>
        </figure>
      </section>

      <section title='Defining New Header Field Parameters'>
        <t>
          Applications that wish to define new parameters for use in the OAuth
          <spanx style='verb'>WWW-Authenticate</spanx> header field MUST register them in the
          parameters registry, following the procedures in <xref target='parameters-registry' />.
        </t>
        <t>
          Parameter names MUST conform to the param-name ABNF and MUST NOT begin with
          <spanx style='verb'>x_</spanx>. Parameter values MUST conform to the param-value ABNF and
          their syntax MUST be well-defined (e.g., using ABNF, or a reference to the syntax of an
          existing parameter).
        </t>
        <figure>
          <artwork>
            <![CDATA[
  param-value  = quoted-value | quoted-string
]]>
          </artwork>
        </figure>
      </section>

      <section title='Defining New Access Grant Types'>
        <t>
          The assertion access grant type allows the authorization server to accept additional
          access grants not specified. Applications that wish to define additional access grant
          types can do so by utilizing a new or existing assertion type and format.
        </t>
      </section>

    </section>

    <section title='Security Considerations'>
      <t>
        [[ TBD ]]
      </t>
    </section>

    <section title='IANA Considerations'>

      <section title='The OAuth Parameters Registry' anchor='parameters-registry'>
        <t>
          This document establishes the OAuth parameters registry.
        </t>
        <t>
          Additional parameters to be use in the end-user authorization endpoint request, the
          end-user authorization endpoint response, the token endpoint request, the token endpoint
          response, or the <spanx style='verb'>WWW-Authenticate</spanx> header field, are
          registered on the advice of one or more Designated Experts (appointed by the IESG or
          their delegate), with a Specification Required (using terminology from 
          <xref target='RFC5226' />). However, to allow for the allocation of values prior to
          publication, the Designated Expert(s) may approve registration once they are satisfied
          that such a specification will be published.
        </t>
        <t>
          Registration requests should be sent to the [TBD]@ietf.org mailing list for review and
          comment, with an appropriate subject (e.g., "Request for parameter: example").
          [[ Note to RFC-EDITOR: The name of the mailing list should be determined in consultation
          with the IESG and IANA. Suggested name: oauth-ext-review. ]]
        </t>
        <t>
          Before a period of 14 days has passed, the Designated Expert(s) will either approve or
          deny the registration request, communicating this decision both to the review list and to
          IANA. Denials should include an explanation and, if applicable, suggestions as to how to
          make the request successful. Registration requests that are undetermined for a period
          longer than 21 days can be brought to the IESG's attention (using the iesg@iesg.org
          mailing list) for resolution.
        </t>

        <section title='Registration Template'>
          <t>
            <list style='hanging'>
              <t hangText='Parameter name:'>
                The name requested (e.g., "example").
              </t>
              <t hangText='Parameter usage location:'>
                The location(s) where parameter can be used. The possible locations are: the
                end-user authorization endpoint request, the end-user authorization endpoint
                response, the token endpoint request, the token endpoint response, the or the
                <spanx style='verb'>WWW-Authenticate</spanx> header field.
              </t>
              <t hangText='Change controller:'>
                For standards-track RFCs, state "IETF". For others, give the name of the
                responsible party. Other details (e.g., postal address, e-mail address, home page
                URI) may also be included.
              </t>
              <t hangText='Specification document(s):'>
                Reference to document that specifies the parameter, preferably including a URI that
                can be used to retrieve a copy of the document. An indication of the relevant
                sections may also be included, but is not required.
              </t>
              <t hangText='Related information:'>
                Optionally, citations to additional documents containing further relevant
                information.
              </t>
            </list>
          </t>
        </section>

        <section title='Example'>
          <t>
            The following is the parameter registration request for the
            <spanx style='verb'>scope</spanx> parameter as defined in this specification:

            <list style='hanging'>
              <t hangText='Parameter name:'>
                scope
              </t>
              <t hangText='Parameter usage location:'>
                The end-user authorization endpoint request, the end-user authorization endpoint
                response, the token endpoint request, the token endpoint response, and the
                <spanx style='verb'>WWW-Authenticate</spanx> header field.
              </t>
              <t hangText='Change controller:'>
                IETF
              </t>
              <t hangText='Specification document(s):'>
                [[ this document ]]
              </t>
              <t hangText='Related information:'>
                None
              </t>
            </list>
          </t>
        </section>

      </section>

    </section>

    <appendix title='Examples'>
      <t>
        [[ TBD ]]
      </t>
    </appendix>

    <appendix title='Contributors'>
      <t>
        The following people contributed to preliminary versions of this document:
        Blaine Cook (BT), Brian Eaton (Google), Yaron Goland (Microsoft), Brent Goldman (Facebook),
        Raffi Krikorian (Twitter), Luke Shepard (Facebook), and Allen Tom (Yahoo!). The content and
        concepts within are a product of the OAuth community, WRAP community, and the OAuth Working
        Group.
      </t>
      <t>
        The OAuth Working Group has dozens of very active contributors who proposed ideas and
        wording for this document, including: [[ If your name is missing or you think someone
        should be added here, please send Eran a note - don't be shy ]]
      </t>
      <t>
        Michael Adams, Andrew Arnott, Dirk Balfanz, Brian Campbell, Leah Culver, Bill de hÓra,
        Brian Ellin, Igor Faynberg, George Fletcher, Tim Freeman, Evan Gilbert, Justin Hart,
        Mike Jones, John Kemp, Chasen Le Hara, Torsten Lodderstedt, Eve Maler, James Manger,
        Laurence Miao, Chuck Mortimore, Justin Richer, Peter Saint-Andre, Nat Sakimura, Rob Sayre,
        Marius Scurtescu, Naitik Shah, Justin Smith, Jeremy Suriel, Christian Stübner, Paul Tarjan,
        and Franklin Tse.
      </t>
    </appendix>

    <appendix title='Acknowledgements'>
      <t>
        [[ Add OAuth 1.0a authors + WG contributors ]]
      </t>
    </appendix>

    <appendix title='Document History'>
      <t>
        [[ to be removed by RFC editor before publication as an RFC ]]
      </t>
      <t>
        -11

        <list style='symbols'>
          <t>
            Many editorial changes. Fixed user authorization section structure.
            Removed unused normative references. Adjusted langugage regarding single use of
            authorization codes.
          </t>
          <t>
            Fixed header ABNF.
          </t>
          <t>
            Change access token description from shared symmetric secret to password.
          </t>
          <t>
            Moved access grant 'none' to a separate section, renamed to 'client_credentials'.
          </t>
          <t>
            Demoted the HTTP status code requirement from MUST to SHOULD in protected resource
            response error.
          </t>
          <t>
            Removed 'expired_token' error code.
          </t>
          <t>
            Moved all the 'code_and_token' parameter to the fragment (from code being in the
            query).
          </t>
          <t>
            Removed 'assertion_type' parameter (moved to 'grant_type').
          </t>
          <t>
            Added note about redirecting to invalid redirection URIs (open redirectors).
          </t>
          <t>
            Removed bearer token section, added new required 'token_type' parameter with
            extensibility.
          </t>
          <t>
            'error-uri' parameter value changed to absolute URI.
          </t>
          <t>
            OAuth 2.0 HTTP authentication scheme name changed to 'OAuth2'.
          </t>
          <t>
            Dropped the 'WWW-Authenticate' header field 'realm' parameter.
          </t>
          <t>
            Removed definition of access token characters.
          </t>
        </list>
      </t>
      <t>
        -10

        <list style='symbols'>
          <t>
            Fixed typos. Many editorial changes. Rewrote introduction. removed terminology
            grouping.
          </t>
          <t>
            Allowed POST for end-user authorization endpoint.
          </t>
          <t>
            Fixed token endpoint to not require client authentication.
          </t>
          <t>
            Made URI query and POST body 'oauth_token' parameter optional.
          </t>
          <t>
            Moved all parameter names and values to use underscores.
          </t>
          <t>
            Changed 'basic_credentials' to 'password', 'invalid_client_credentials' and
            'invalid_client_id' to 'invalid_client'.
          </t>
          <t>
            Added note that access token requests without an access grant should not include
            a refresh token.
          </t>
          <t>
            Changed scheme name from 'Token' to 'OAuth', simplified request format to simple
            string for token instead of key=value pair (still supported for extensions).
          </t>
          <t>
            Defined permitted access token string characters (suitable for inclusion in an HTTP
            header).
          </t>
          <t>
            Added a note about conflicts with previous versions.
          </t>
          <t>
            Moved 'client_id' definition from client authentication to access token endpoint.
          </t>
          <t>
            Added definition for 'access grant'.
          </t>
        </list>
      </t>
      <t>
        -09

        <list style='symbols'>
          <t>
            Fixed typos, editorial changes.
          </t>
          <t>
            Added token expiration example.
          </t>
          <t>
            Added scope parameter to end-user authorization endpoint response.
          </t>
          <t>
            Added note about parameters with empty values (same as omitted).
          </t>
          <t>
            Changed parameter values to use '-' instead of '_'. Parameter names still use '_'.
          </t>
          <t>
            Changed authorization endpoint client type to response type with values: code, token,
            and both.
          </t>
          <t>
            Complete cleanup of error codes. Added support for error description and URI.
          </t>
          <t>
            Add initial extensibility support.
          </t>
        </list>
      </t>
      <t>
        -08

        <list style='symbols'>
          <t>
            Renamed verification code to authorization code.
          </t>
          <t>
            Revised terminology, structured section, added new terms.
          </t>
          <t>
            Changed flows to profiles and moved to introduction.
          </t>
          <t>
            Added support for access token rescoping.
          </t>
          <t>
            Cleaned up client credentials section.
          </t>
          <t>
            New introduction overview.
          </t>
          <t>
            Added error code for invalid username and password, and renamed error code to be more
            consistent.
          </t>
          <t>
            Added access grant type parameter to token endpoint.
          </t>
        </list>
      </t>
      <t>
        -07

        <list style='symbols'>
          <t>
            Major rewrite of entire document structure.
          </t>
          <t>
            Removed device profile.
          </t>
          <t>
            Added verification code support to user-agent flow.
          </t>
          <t>
            Removed multiple formats support, leaving JSON as the only format.
          </t>
          <t>
            Changed assertion <spanx style='verb'>assertion_format</spanx> parameter to
            <spanx style='verb'>assertion_type</spanx>.
          </t>
          <t>
            Removed <spanx style='verb'>type</spanx> parameter from token endpoint.
          </t>
        </list>
      </t>
      <t>
        -06

        <list style='symbols'>
          <t>
            Editorial changes, corrections, clarifications, etc.
          </t>
          <t>
            Removed conformance section.
          </t>
          <t>
            Moved authors section to contributors appendix.
          </t>
          <t>
            Added section on native applications.
          </t>
          <t>
            Changed error response to use the requested format. Added support for HTTP
            <spanx style='verb'>Accept</spanx> header.
          </t>
          <t>
            Flipped the order of the web server and user-agent flows.
          </t>
          <t>
            Renamed assertion flow <spanx style='verb'>format</spanx> parameter name to
            <spanx style='verb'>assertion_format</spanx> to resolve conflict.
          </t>
          <t>
            Removed the term identifier from token definitions. Added a cryptographic token
            definition.
          </t>
          <t>
            Added figure titles.
          </t>
          <t>
            Added server response 401 when client tried to authenticate using multiple credentials.
          </t>
          <t>
            Clarified support for TLS alternatives, and added requirement for TLS 1.2 support for
            token endpoint.
          </t>
          <t>
            Removed all signature and cryptography.
          </t>
          <t>
            Removed all discovery.
          </t>
          <t>
            Updated HTML4 reference.
          </t>
        </list>
      </t>
      <t>
        -05

        <list style='symbols'>
          <t>
            Corrected device example.
          </t>
          <t>
            Added client credentials parameters to the assertion flow as OPTIONAL.
          </t>
          <t>
            Added the ability to send client credentials using an HTTP authentication scheme.
          </t>
          <t>
            Initial text for the <spanx style='verb'>WWW-Authenticate</spanx> header (also added
            scope support).
          </t>
          <t>
            Change authorization endpoint to end-user endpoint.
          </t>
          <t>
            In the device flow, change the <spanx style='verb'>user_uri</spanx> parameter to
            <spanx style='verb'>verification_uri</spanx> to avoid confusion with the end-user
            endpoint.
          </t>
          <t>
            Add <spanx style='verb'>format</spanx> request parameter and support for XML and
            form-encoded responses.
          </t>
        </list>
      </t>
      <t>
        -04

        <list style='symbols'>
          <t>
            Changed all token endpoints to use <spanx style='verb'>POST</spanx>
          </t>
          <t>
            Clarified the authorization server's ability to issue a new refresh token when
            refreshing a token.
          </t>
          <t>
            Changed the flow categories to clarify the autonomous group.
          </t>
          <t>
            Changed client credentials language not to always be server-issued.
          </t>
          <t>
            Added a <spanx style='verb'>scope</spanx> response parameter.
          </t>
          <t>
            Fixed typos.
          </t>
          <t>
            Fixed broken document structure.
          </t>
        </list>
      </t>
      <t>
        -03

        <list style='symbols'>
          <t>
            Fixed typo in JSON error examples.
          </t>
          <t>
            Fixed general typos.
          </t>
          <t>
            Moved all flows sections up one level.
          </t>
        </list>
      </t>
      <t>
        -02

        <list style='symbols'>
          <t>
            Removed restriction on <spanx style='verb'>redirect_uri</spanx> including a query.
          </t>
          <t>
            Added <spanx style='verb'>scope</spanx> parameter.
          </t>
          <t>
            Initial proposal for a JSON-based token response format.
          </t>
        </list>
      </t>
      <t>
        -01

        <list style='symbols'>
          <t>
            Editorial changes based on feedback from Brian Eaton, Bill Keenan, and Chuck Mortimore.
          </t>
          <t>
            Changed device flow <spanx style='verb'>type</spanx> parameter values and switch to use
            only the token endpoint.
          </t>
        </list>
      </t>
      <t>
        -00

        <list style='symbols'>
          <t>
            Initial draft based on a combination of WRAP and OAuth 1.0a.
          </t>
        </list>
      </t>
    </appendix>

  </middle>

  <back>

    <references title='Normative References'>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2828.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3023.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5849.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-html401-19991224.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p1-messaging-09.xml'?>

    </references>

    <references title='Informative References'>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml' ?>

    </references>

  </back>

</rfc>
